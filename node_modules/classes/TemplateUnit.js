const MOVE_ORDER = "move_order";
const ATTACK_MOVE_ORDER = "attack_move_order";

class TemplateUnit{
  constructor( options ){
    this.pos = {
      x: 0,
      y: 0
    };

    this.path = [];
    this.target = false;
    this.fill = "red";

    for( var i in options ){
      this[ i ] = options[ i ];
    }
  }

  assignTeam( team ){
    this.team = team;
  }

  getTarget(){
    return this.target;
  }
  setTarget( target ){
    this.target = target;
  }

  draw( ctx ){

    var x = this.pos.x * TileWidth;
    var y = this.pos.x * TileWidth;

    if( typeof this["stroke"] !== "undefined" ){
      ctx.beginPath();
      ctx.rect( this.pos.x * TileHeight, this.pos.y * TileHeight, TileWidth, TileHeight );
      ctx.strokeColor = this["stroke"];
      ctx.stroke();
      ctx.closePath();
    }

    if( typeof this["fill"] !== "undefined" ){
      ctx.beginPath();
      ctx.rect( this.pos.x * TileHeight, this.pos.y * TileHeight, TileWidth, TileHeight );
      ctx.fillStyle = this["fill"];
      ctx.fill();
      ctx.closePath();
    }
  }
  drawSelection( ctx ){
      ctx.beginPath();
      ctx.rect( ( this.pos.x * TileHeight ) - 2, ( this.pos.y * TileHeight ) - 2, TileWidth + 4, TileHeight + 4 );
      ctx.strokeColor = "green";
      ctx.stroke();
      ctx.closePath();
  }
  logic(){
    console.log("update");
    if( this.path.length > 0 ){
      this.updatePosition();
    }
  }
  moveOrder( pos ){
    this.state = MOVE_ORDER;
    this.path = PathTracking(
      this.Map.path,
      [ parseInt( this.pos.x ), parseInt( this.pos.y ) ],
      [ parseInt( pos.x ), parseInt( pos.y ) ] );
    if( this.path.length > 1 ){
      this.path.shift();
    }
  }
  attackMoveOrder(){
    this.state = ATTACK_MOVE_ORDER;
  }
  updatePosition(){
    var pathX = parseFloat( this.path[0][0] );
    var pathY = parseFloat( this.path[0][1] );

    var currentX = parseFloat( this.pos.x );
    var currentY = parseFloat( this.pos.y );

    var newX = currentX;
    var newY = currentY;

    // var speed = this.speed;
    var speed = 0.1;

    var diffX = Math.abs( parseFloat( currentX - pathX ).toPrecision( 12 ) );
    var diffY = Math.abs( parseFloat(currentY - pathX ).toPrecision( 12 ) );

    if( currentX < pathX ){
      newX = ( parseFloat( newX + speed ).toPrecision( 12 ) );
    } else if( currentX > pathX ){
      newX = ( parseFloat( newX - speed ).toPrecision( 12 ) );
    }

    if( currentY < pathY ){
      newY = ( parseFloat( newY + speed ).toPrecision( 12 ) );
    } else if( currentY > pathY ){
      newY = ( parseFloat( newY - speed ).toPrecision( 12 ) );
    }

    if( pathX == newX && pathY == newY ){
      this.path.shift();
    }

    this.pos = {
      x: parseFloat( newX ).toPrecision( 12 ),
      y: parseFloat( newY ).toPrecision( 12 )
    };
  }
}
module.exports = { unit: TemplateUnit };
